var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var npo_src = createCommonjsModule(function (module) {
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name,context,definition){
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if ('object' != "undefined" && module.exports) { module.exports = context[name]; }
	else if (typeof undefined == "function" && undefined.amd) { undefined(function $AMD$(){ return context[name]; }); }
})("Promise",typeof commonjsGlobal != "undefined" ? commonjsGlobal : commonjsGlobal,function DEF(){
	/*jshint validthis:true */
	var builtInProp, cycle, scheduling_queue,
		ToString = Object.prototype.toString,
		timer = (typeof setImmediate != "undefined") ?
			function timer(fn) { return setImmediate(fn); } :
			setTimeout;

	// dammit, IE8.
	try {
		Object.defineProperty({},"x",{});
		builtInProp = function builtInProp(obj,name,val,config) {
			return Object.defineProperty(obj,name,{
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	}
	catch (err) {
		builtInProp = function builtInProp(obj,name,val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = (function Queue() {
		var first, last, item;

		function Item(fn,self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn,self) {
				item = new Item(fn,self);
				if (last) {
					last.next = item;
				}
				else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	})();

	function schedule(fn,self) {
		scheduling_queue.add(fn,self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then, o_type = typeof o;

		if (o != null &&
			(
				o_type == "object" || o_type == "function"
			)
		) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i=0; i<this.chain.length; i++) {
			notifyIsolated(
				this,
				(this.state === 1) ? this.chain[i].success : this.chain[i].failure,
				this.chain[i]
			);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self,cb,chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			}
			else {
				if (cb === true) {
					ret = self.msg;
				}
				else {
					ret = cb.call(void 0,self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				}
				else if (_then = isThenable(ret)) {
					_then.call(ret,chain.resolve,chain.reject);
				}
				else {
					chain.resolve(ret);
				}
			}
		}
		catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then, self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function(){
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg,
							function $resolve$(){ resolve.apply(def_wrapper,arguments); },
							function $reject$(){ reject.apply(def_wrapper,arguments); }
						);
					}
					catch (err) {
						reject.call(def_wrapper,err);
					}
				});
			}
			else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify,self);
				}
			}
		}
		catch (err) {
			reject.call(new MakeDefWrapper(self),err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify,self);
		}
	}

	function iteratePromises(Constructor,arr,resolver,rejecter) {
		for (var idx=0; idx<arr.length; idx++) {
			(function IIFE(idx){
				Constructor.resolve(arr[idx])
				.then(
					function $resolver$(msg){
						resolver(idx,msg);
					},
					rejecter
				);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success,failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve,reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify,def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0,failure);
		};

		try {
			executor.call(
				void 0,
				function publicResolve(msg){
					resolve.call(def,msg);
				},
				function publicReject(msg) {
					reject.call(def,msg);
				}
			);
		}
		catch (err) {
			reject.call(def,err);
		}
	}

	var PromisePrototype = builtInProp({},"constructor",Promise,
		/*configurable=*/false
	);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype,"__NPO__",0,
		/*configurable=*/false
	);

	builtInProp(Promise,"resolve",function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise,"reject",function Promise$reject(msg) {
		return new this(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise,"all",function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length, msgs = Array(len), count = 0;

			iteratePromises(Constructor,arr,function resolver(idx,msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			},reject);
		});
	});

	builtInProp(Promise,"race",function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor,arr,function resolver(idx,msg){
				resolve(msg);
			},reject);
		});
	});

	return Promise;
});
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};









function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/** All possible Checkout user interfaces. */
var UI;
(function (UI) {
    UI["Fullscreen"] = "fullscreen";
    UI["Modal"] = "modal";
    UI["Inline"] = "inline";
})(UI || (UI = {}));
// tslint:disable-next-line:completed-docs
var DEFAULT_COMMON_OPTIONS = {
    // Ideally, the default UI should be overriden for all concrete implementations.
    ui: UI.Fullscreen,
    language: "en-US",
    endpoint: "https://v1.checkout.bambora.com"
};
// tslint:disable-next-line:completed-docs
var DEFAULT_REDIRECT_OPTIONS = __assign({}, DEFAULT_COMMON_OPTIONS, { ui: UI.Fullscreen });
// tslint:disable-next-line:completed-docs
var DEFAULT_MODAL_OPTIONS = __assign({}, DEFAULT_COMMON_OPTIONS, { ui: UI.Modal });
// tslint:disable-next-line:completed-docs
var DEFAULT_INLINE_OPTIONS = __assign({}, DEFAULT_COMMON_OPTIONS, { ui: UI.Inline, container: null });
/** Maps an options object to a client-side objects object. */
function mapOptionsToClientSideOptions(options) {
    var styles = options.styles, labels = options.labels, demo = options.demo;
    var version = "3.0.6";
    if (window && typeof window["__bambora-system"] === "string") {
        version += "-" + window["__bambora-system"];
    }
    return { styles: styles, labels: labels, demo: demo, version: version };
}
/** Maps an options object to a server-side objects object. */
function mapOptionsToServerSideOptions(options) {
    var ui = options.ui, language = options.language;
    return { ui: ui, language: language };
}
/** Converts a client-side options object to a base64 string. */
function optionsToBase64(options) {
    var stringified = JSON.stringify(options);
    return stringified === "{}" ? "" : btoa(stringified);
}
/** Converts a server-side options object to a URL-friendly query string. */
function optionsToQueryString(options) {
    return Object.keys(options)
        .map(function (key) {
        return encodeURIComponent(key) + "=" + encodeURIComponent(options[key]);
    })
        .join("&");
}

/** All possible actions that Checkout responds to. */
var Action;
(function (Action) {
    /** Load a Checkout session. */
    Action["LoadSession"] = "loadSession";
    /**
     * Handshake with the iframe document and establish
     * a channel for communication.
     */
    Action["InitiateHandshake"] = "initiateHandshake";
    /**
     * Is sent as a response to the `Close` and `Cancel` events.
     * Acknowledges a request from Checkout to close the modal and
     * prevents Checkout from redirecting.
     */
    Action["AcknowledgeCloseRequest"] = "acknowledgeCloseRequest";
})(Action || (Action = {}));
var Action$1 = Action;

// tslint:disable:max-classes-per-file
// tslint:disable:early-exit
// Ponyfill for setPrototypeOf
var setPrototypeOf = Object.setPrototypeOf ||
    (function (obj, proto) {
        obj.__proto__ = proto;
        return obj;
    });
/** Thrown when a session token is required but has not been provided. */
var NoSessionTokenProvidedError = /** @class */ (function (_super) {
    __extends(NoSessionTokenProvidedError, _super);
    function NoSessionTokenProvidedError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        setPrototypeOf(_this, _newTarget.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NoSessionTokenProvidedError);
        }
        return _this;
    }
    return NoSessionTokenProvidedError;
}(ReferenceError));
/** Thrown when there was a problem loading a session. */
var LoadSessionError = /** @class */ (function (_super) {
    __extends(LoadSessionError, _super);
    function LoadSessionError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        setPrototypeOf(_this, _newTarget.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, LoadSessionError);
        }
        return _this;
    }
    return LoadSessionError;
}(Error));
/** Thrown when the response to a message has resulted in an error. */
var GenericMessageError = /** @class */ (function (_super) {
    __extends(GenericMessageError, _super);
    function GenericMessageError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        setPrototypeOf(_this, _newTarget.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, GenericMessageError);
        }
        return _this;
    }
    return GenericMessageError;
}(Error));
/** Thrown when handshaking could not be completed. */
var HandshakeError = /** @class */ (function (_super) {
    __extends(HandshakeError, _super);
    function HandshakeError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        setPrototypeOf(_this, _newTarget.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, HandshakeError);
        }
        return _this;
    }
    return HandshakeError;
}(Error));
/** Thrown when a container is required but has not been provided. */
var ContainerNotSpecifiedError = /** @class */ (function (_super) {
    __extends(ContainerNotSpecifiedError, _super);
    function ContainerNotSpecifiedError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        setPrototypeOf(_this, _newTarget.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ContainerNotSpecifiedError);
        }
        return _this;
    }
    return ContainerNotSpecifiedError;
}(Error));



var errors = Object.freeze({
	NoSessionTokenProvidedError: NoSessionTokenProvidedError,
	LoadSessionError: LoadSessionError,
	GenericMessageError: GenericMessageError,
	HandshakeError: HandshakeError,
	ContainerNotSpecifiedError: ContainerNotSpecifiedError
});

//      
// An event handler can take an optional event argument
// and should not return a value
                                          
                                                               

// An array of all currently registered event handlers for a type
                                            
                                                            
// A map of event types and their corresponding event handlers.
                        
                                 
                                   
  

/** Mitt: Tiny (~200b) functional event emitter / pubsub.
 *  @name mitt
 *  @returns {Mitt}
 */
function mitt(all                 ) {
	all = all || Object.create(null);

	return {
		/**
		 * Register an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to listen for, or `"*"` for all events
		 * @param  {Function} handler Function to call in response to given event
		 * @memberOf mitt
		 */
		on: function on(type        , handler              ) {
			(all[type] || (all[type] = [])).push(handler);
		},

		/**
		 * Remove an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
		 * @param  {Function} handler Handler function to remove
		 * @memberOf mitt
		 */
		off: function off(type        , handler              ) {
			if (all[type]) {
				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
			}
		},

		/**
		 * Invoke all handlers for the given type.
		 * If present, `"*"` handlers are invoked after type-matched handlers.
		 *
		 * @param {String} type  The event type to invoke
		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
		 * @memberOf mitt
		 */
		emit: function emit(type        , evt     ) {
			(all[type] || []).slice().map(function (handler) { handler(evt); });
			(all['*'] || []).slice().map(function (handler) { handler(type, evt); });
		}
	};
}

/** All possible events that Checkout emits. */
var CheckoutEvent;
(function (CheckoutEvent) {
    /** A payment has been authorized. */
    CheckoutEvent["Authorize"] = "authorize";
    /**
     * The Checkout session has been canceled.
     * Checkout requests for its modal to be closed.
     *
     * To avoid a redirect, reply immediately with the
     * `AcknowledgeCloseRequest` action.
     */
    CheckoutEvent["Cancel"] = "cancel";
    /**
     * The Checkout session has been completed.
     * Checkout requests for its modal to be closed.
     *
     * To avoid a redirect, reply immediately with the
     * `AcknowledgeCloseRequest` action.
     */
    CheckoutEvent["Close"] = "close";
    /** A payment type has been selected. */
    CheckoutEvent["PaymentTypeSelection"] = "paymentTypeSelection";
    /** The payment card type has been determined. */
    CheckoutEvent["CardTypeResolve"] = "cardTypeResolve";
})(CheckoutEvent || (CheckoutEvent = {}));
var CheckoutEvent$1 = CheckoutEvent;
/** The emitter factory function. Creates a new emitter. */
// tslint:disable-next-line:naming-convention
var createEmitter = mitt;

// tslint:disable-next-line:completed-docs
var AsyncIframe = /** @class */ (function () {
    function AsyncIframe(source, container, origin, eventHandlerMap) {
        this._origin = origin;
        // Generate unique iframe ID
        this._id = "iframe_" + Math.random()
            .toString(36)
            .substring(2, 15);
        // Hook up emitter
        var emitter = createEmitter(eventHandlerMap);
        this.on = emitter.on.bind(this);
        this.off = emitter.off.bind(this);
        this._emit = emitter.emit.bind(this);
        // Create iframe element promise
        this._iframeElement = this._createIFrameElementAsync(source, container);
    }
    /** Removes iframe from the DOM and unhooks all events. */
    AsyncIframe.prototype.destroy = function () {
        var iframe = document.getElementById(this._id);
        window.removeEventListener("message", this._onMessageListener);
        delete this.on;
        delete this.off;
        delete this._emit;
        if (!iframe)
            return;
        iframe.parentElement.removeChild(iframe);
    };
    Object.defineProperty(AsyncIframe.prototype, "element", {
        /** Resolves to the HTMLIFrameElement upon handshake completion. */
        get: function () {
            return this._iframeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Posts a message to the iframe content documents.
     * Resolves or rejects with a reply or acknowledgement from the iframe.
     */
    AsyncIframe.prototype.postMessage = function (message, 
    // The iframeElement parameter should only be used for the initial handshake.
    iframeElement) {
        return __awaiter(this, void 0, void 0, function () {
            var iframe, _a, origin, messageId, messagePromise;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = iframeElement;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.element];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        iframe = _a;
                        origin = this._origin;
                        messageId = "message_" + Math.random()
                            .toString(36)
                            .substring(2, 15);
                        messagePromise = new Promise(function (resolve, reject) {
                            window.addEventListener("message", onMessage, false);
                            function onMessage(event) {
                                if (event.origin !== origin)
                                    return;
                                if (!event.data || event.data.messageId !== messageId)
                                    return;
                                window.removeEventListener("message", onMessage);
                                var payload = event.data.payload;
                                if (!event.data.result) {
                                    reject(new GenericMessageError(payload));
                                }
                                resolve(payload);
                            }
                        });
                        iframe.contentWindow.postMessage(__assign({}, message, { messageId: messageId }), this._origin);
                        return [2 /*return*/, messagePromise];
                }
            });
        });
    };
    AsyncIframe.prototype._createIFrameElementAsync = function (source, container) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var iframeElementPromise, iframeElement;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        iframeElementPromise = new Promise(function (resolve, reject) {
                            var createdIframeElement = _this._createIframeElement();
                            createdIframeElement.onload = function () { return resolve(createdIframeElement); };
                            createdIframeElement.onerror = function () { return reject(createdIframeElement); };
                            createdIframeElement.setAttribute("src", source);
                            container.appendChild(createdIframeElement);
                        });
                        return [4 /*yield*/, iframeElementPromise];
                    case 1:
                        iframeElement = _a.sent();
                        this._rebindIframeEventHandlers(iframeElement);
                        this._initiateEventProxy();
                        return [4 /*yield*/, this._initiateHandshake(iframeElement)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, iframeElement];
                }
            });
        });
    };
    AsyncIframe.prototype._createIframeElement = function () {
        var iframeElement = document.createElement("iframe");
        iframeElement.setAttribute("id", this._id);
        iframeElement.setAttribute("name", this._id);
        iframeElement.setAttribute("frameborder", "0");
        iframeElement.setAttribute("allowTransparency", "true");
        iframeElement.setAttribute("style", "width:100%; height:100%;");
        return iframeElement;
    };
    AsyncIframe.prototype._initiateHandshake = function (iframeElement) {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.postMessage({
                                action: Action$1.InitiateHandshake,
                                payload: this._id
                            }, iframeElement)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        throw new HandshakeError(error_1.message);
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    AsyncIframe.prototype._initiateEventProxy = function () {
        this._onMessageListener = this._onMessage.bind(this);
        window.addEventListener("message", this._onMessageListener, false);
    };
    AsyncIframe.prototype._onMessage = function (event) {
        if (event.origin !== this._origin)
            return;
        if (!event.data || event.data.handshakeId !== this._id)
            return;
        this._emit(event.data.event, event.data.payload);
    };
    AsyncIframe.prototype._rebindIframeEventHandlers = function (iframeElement) {
        var _this = this;
        iframeElement.onload = function () { return _this._initiateHandshake(iframeElement); };
        iframeElement.onerror = null;
        return iframeElement;
    };
    return AsyncIframe;
}());
/** Takes a URL and returns its origin. */
function getOrigin(url) {
    url = url.indexOf("blob:") === 0 ? url.slice(5) : url;
    var a = document.createElement("a");
    a.setAttribute("href", url);
    return (a.protocol + "//" + a.hostname +
        (a.port !== "80" && a.port !== "443" && a.port !== "0" && a.port
            ? ":" + a.port
            : ""));
}

// tslint:disable-next-line:completed-docs
var AbstractCheckout = /** @class */ (function () {
    function AbstractCheckout(sessionToken, options) {
        this.sessionToken = sessionToken;
        this._options = __assign({}, DEFAULT_COMMON_OPTIONS, options);
    }
    /**
     * Initializes a session by its session token.
     * Throws `NoSessionTokenProvidedError` if no session token has been provided.
     */
    AbstractCheckout.prototype.initialize = function (sessionToken) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (sessionToken)
                    this.sessionToken = sessionToken;
                if (!this.sessionToken) {
                    throw new NoSessionTokenProvidedError("A session invocation was attempted while no session token was provided.");
                }
                return [2 /*return*/, this.sessionToken];
            });
        });
    };
    Object.defineProperty(AbstractCheckout.prototype, "_checkoutUrl", {
        get: function () {
            var clientSideOptions = mapOptionsToClientSideOptions(this._options);
            var serverSideOptions = mapOptionsToServerSideOptions(this._options);
            var anchorString = optionsToBase64(clientSideOptions);
            if (anchorString)
                anchorString = "#" + anchorString;
            var queryString = "?" + optionsToQueryString(serverSideOptions);
            if (!this.sessionToken) {
                return "" + this._options.endpoint + queryString + anchorString;
            }
            return this._options.endpoint + "/" + this.sessionToken + queryString + anchorString;
        },
        enumerable: true,
        configurable: true
    });
    return AbstractCheckout;
}());

// tslint:disable-next-line:completed-docs
var AbstractIframeCheckout = /** @class */ (function (_super) {
    __extends(AbstractIframeCheckout, _super);
    function AbstractIframeCheckout(sessionToken, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, sessionToken, options) || this;
        /** Used to avoid an exception thrown in `iframe` getter when the container is falsy. */
        _this._container = null;
        // Hook up emitter.
        var emitter = createEmitter(_this._options.eventHandlerMap);
        _this.on = emitter.on.bind(_this);
        _this.off = emitter.off.bind(_this);
        _this._emit = emitter.emit.bind(_this);
        return _this;
    }
    /** Removes iframe from the DOM and unhooks all events. */
    AbstractIframeCheckout.prototype.destroy = function () {
        this._asyncIframe.destroy();
        delete this.on;
        delete this.off;
        delete this._emit;
    };
    /**
     * Tells the iframed Checkout to load a session via the `sessionToken` parameter.
     * Resolves upon successful load of session.
     * Throws `NoSessionTokenProvidedError` if no session token has been provided.
     * Throws `LoadSessionError` on failure to load session.
     */
    AbstractIframeCheckout.prototype.initialize = function (sessionToken) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this._loadSession;
                        return [4 /*yield*/, _super.prototype.initialize.call(this, sessionToken)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        });
    };
    Object.defineProperty(AbstractIframeCheckout.prototype, "iframe", {
        /**
         * Resolves to the `HTMLIFrameElement` iframe.
         * Throws `ContainerNotSpecifiedError` when trying to access the element
         * without having mounted it to any container.
         */
        get: function () {
            return this._asyncIframe.element;
        },
        enumerable: true,
        configurable: true
    });
    AbstractIframeCheckout.prototype._createAsyncIframe = function () {
        var _this = this;
        if (this.__asyncIframe)
            return;
        if (this._container === null) {
            throw new ContainerNotSpecifiedError("A container must be specified before accessing the iframe.");
        }
        var url = this._checkoutUrl;
        var origin = getOrigin(url);
        this.__asyncIframe = new AsyncIframe(url, this._container, origin, {
            // Re-emit everything:
            "*": [function (type, event) { return _this._emit(type, event); }]
        });
    };
    AbstractIframeCheckout.prototype._loadSession = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var response, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._lastSessionToken) {
                            if (token === this._lastSessionToken) {
                                return [2 /*return*/, Promise.resolve(token)];
                            }
                            throw new LoadSessionError("Loading a different session is not supported. Try creating a new Checkout instance.");
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._asyncIframe.postMessage({
                                action: Action$1.LoadSession,
                                payload: token
                            })];
                    case 2:
                        response = _a.sent();
                        this._lastSessionToken = token;
                        return [2 /*return*/, response];
                    case 3:
                        error_1 = _a.sent();
                        throw new LoadSessionError(error_1.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(AbstractIframeCheckout.prototype, "_asyncIframe", {
        get: function () {
            // The iframe is automatically created and mounted.
            this._createAsyncIframe();
            return this.__asyncIframe;
        },
        enumerable: true,
        configurable: true
    });
    return AbstractIframeCheckout;
}(AbstractCheckout));

/**
 * A class for creating an inline Checkout experience.
 * Creates an iframe containing Checkout and handles all communication.
 */
var InlineCheckout = /** @class */ (function (_super) {
    __extends(InlineCheckout, _super);
    function InlineCheckout(sessionToken, options) {
        if (options === void 0) { options = __assign({}, DEFAULT_INLINE_OPTIONS); }
        var _this = _super.call(this, sessionToken, __assign({}, DEFAULT_INLINE_OPTIONS, options)) || this;
        if (_this._options.container === null)
            return _this;
        // If the container is specified, create async iframe and mount it.
        _this._container = _this._options.container;
        _this._createAsyncIframe();
        return _this;
    }
    /** Mounts the iframe to the specified container. */
    InlineCheckout.prototype.mount = function (container) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Set this._container to avoid exceptions when trying to access
                        // this.iframe immediately after.
                        this._container = container;
                        return [4 /*yield*/, this.iframe];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return InlineCheckout;
}(AbstractIframeCheckout));

/**
 * A class for creating a redirect Checkout experience.
 * Redirects in the `constructor` if a session token is provided.
 * To prevent the redirect, omit the session token from the constructor
 * and provide it via the `initialize` instance method instead.
 */
var RedirectCheckout = /** @class */ (function (_super) {
    __extends(RedirectCheckout, _super);
    function RedirectCheckout(sessionToken, options) {
        if (options === void 0) { options = __assign({}, DEFAULT_REDIRECT_OPTIONS); }
        var _this = _super.call(this, sessionToken, __assign({}, DEFAULT_REDIRECT_OPTIONS, options)) || this;
        if (!_this.sessionToken)
            return _this;
        _this._redirect(_this._checkoutUrl);
        return _this;
    }
    /**
     * Resolves to the URL for the Checkout session.
     * Throws `NoSessionTokenProvidedError` if no session token has been provided.
     */
    RedirectCheckout.prototype.initialize = function (sessionToken) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.initialize.call(this, sessionToken)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this._checkoutUrl];
                }
            });
        });
    };
    RedirectCheckout.prototype._redirect = function (url) {
        window.location.assign(url);
    };
    return RedirectCheckout;
}(AbstractCheckout));

/**
 * A class for creating a modal Checkout experience.
 * Creates an iframe containing Checkout and handles all communication.
 * Creates an overlay and handles showing and hiding of it.
 */
var ModalCheckout = /** @class */ (function (_super) {
    __extends(ModalCheckout, _super);
    function ModalCheckout(sessionToken, options) {
        if (options === void 0) { options = __assign({}, DEFAULT_MODAL_OPTIONS); }
        var _this = _super.call(this, sessionToken, __assign({}, DEFAULT_MODAL_OPTIONS, options)) || this;
        _this._isActive = false;
        /**
         * The element that initiated showing the modal.
         * We return focus to this element when hiding the modal
         * to improve accessibility.
         */
        _this._initiatingElement = null;
        _this._enableBodyScroll = null;
        createAndApplyStyleSheet(_this._options.cspNonce);
        _this._id = Math.random()
            .toString(36)
            .substring(2, 15);
        _this._overlayContainer = _this._createOverlayContainer();
        _this._backdrop = _this._createBackdrop();
        _this._container = _this._createIframeContainer();
        document.body.appendChild(_this._overlayContainer);
        _this._overlayContainer.appendChild(_this._backdrop);
        _this._overlayContainer.appendChild(_this._createFocusTrap());
        _this._overlayContainer.appendChild(_this._container);
        _this._overlayContainer.appendChild(_this._createFocusTrap());
        _this._createAsyncIframe();
        _this.on(CheckoutEvent$1.Cancel, _this.hide.bind(_this));
        _this.on(CheckoutEvent$1.Close, _this.hide.bind(_this));
        return _this;
    }
    /**
     * Removes the overlay and iframe from the DOM and unhooks all events.
     * If executed while the modal is displayed, body scrolling will be reenabled.
     */
    ModalCheckout.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this._overlayContainer.parentElement.removeChild(this._overlayContainer);
        if (!this._enableBodyScroll)
            return;
        this._enableBodyScroll();
    };
    /** Shows the modal overlay. Resolves upon animation finish. */
    ModalCheckout.prototype.show = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var coordinates, viewportDifference, iframeContainer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._isActive)
                            return [2 /*return*/];
                        this._isActive = true;
                        return [4 /*yield*/, this.iframe];
                    case 1:
                        _a.sent();
                        this._initiatingElement = (event && event.target) || null;
                        coordinates = this._getElementCoordinates();
                        viewportDifference = this._getViewportDifference(coordinates);
                        iframeContainer = this._container;
                        iframeContainer.style.transform = "translateX(" + viewportDifference.x + "px) translateY(" + viewportDifference.y + "px)";
                        iframeContainer.style["-webkit-transform"] =
                            iframeContainer.style.transform;
                        this._overlayContainer.classList.add(Style.Enter);
                        this._overlayContainer.style.display = "block";
                        return [4 /*yield*/, delay(0)];
                    case 2:
                        _a.sent();
                        iframeContainer.style.transform = "translateX(0) translateY(0)";
                        iframeContainer.style["-webkit-transform"] =
                            iframeContainer.style.transform;
                        this._overlayContainer.classList.add(Style.EnterActive);
                        this._enableBodyScroll = disableBodyScroll();
                        return [4 /*yield*/, delay(ModalCheckout.ANIMATION_DURATION)];
                    case 3:
                        _a.sent();
                        iframeContainer.focus();
                        this._overlayContainer.classList.remove(Style.Enter, Style.EnterActive);
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Hides the modal overlay. Resolves upon animation finish. */
    ModalCheckout.prototype.hide = function (target) {
        return __awaiter(this, void 0, void 0, function () {
            var coordinates, viewportDifference, iframeContainer, initiatingElement;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._isActive)
                            return [2 /*return*/];
                        this._isActive = false;
                        coordinates = this._getElementCoordinates(target);
                        viewportDifference = this._getViewportDifference(coordinates);
                        iframeContainer = this._container;
                        if (this._enableBodyScroll) {
                            this._enableBodyScroll();
                            this._enableBodyScroll = null;
                        }
                        iframeContainer.style.transform = "translateX(0) translateY(0)";
                        iframeContainer.style["-webkit-transform"] =
                            iframeContainer.style.transform;
                        this._overlayContainer.classList.add(Style.Leave);
                        return [4 /*yield*/, delay(0)];
                    case 1:
                        _a.sent();
                        iframeContainer.style.transform = "translateX(" + viewportDifference.x + "px) translateY(" + viewportDifference.y + "px)";
                        iframeContainer.style["-webkit-transform"] =
                            iframeContainer.style.transform;
                        this._overlayContainer.classList.add(Style.LeaveActive);
                        return [4 /*yield*/, delay(ModalCheckout.ANIMATION_DURATION)];
                    case 2:
                        _a.sent();
                        initiatingElement = this._initiatingElement;
                        if (initiatingElement && initiatingElement.focus) {
                            initiatingElement.focus();
                        }
                        this._initiatingElement = null;
                        this._overlayContainer.style.display = "none";
                        this._overlayContainer.classList.remove(Style.Leave, Style.LeaveActive);
                        return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(ModalCheckout.prototype, "isActive", {
        /** Is `true` when the modal is visible. */
        get: function () {
            return this._isActive;
        },
        enumerable: true,
        configurable: true
    });
    ModalCheckout.prototype._getElementCoordinates = function (target) {
        var element = target && target.getBoundingClientRect ? target : this._initiatingElement;
        if (!element) {
            return { x: 0, y: 0 };
        }
        var boundingClientRect = element.getBoundingClientRect();
        return {
            x: boundingClientRect.left + boundingClientRect.width / 2,
            y: boundingClientRect.top + boundingClientRect.height / 2
        };
    };
    ModalCheckout.prototype._getViewportDifference = function (coordinates) {
        if (!coordinates.x)
            return { x: 0, y: 0 };
        return {
            x: (coordinates.x || 0) - window.innerWidth / 2,
            y: (coordinates.y || 0) - window.innerHeight / 2
        };
    };
    ModalCheckout.prototype._createOverlayContainer = function () {
        var overlayContainer = document.createElement("div");
        overlayContainer.setAttribute("id", "bc-overlay-container-" + this._id);
        overlayContainer.setAttribute("aria-label", "Bambora Checkout");
        overlayContainer.setAttribute("role", "dialog");
        overlayContainer.style.display = "none";
        overlayContainer.classList.add(Style.OverlayContainer);
        return overlayContainer;
    };
    ModalCheckout.prototype._createIframeContainer = function () {
        var iframeContainer = document.createElement("div");
        iframeContainer.setAttribute("id", "bc-iframe-container-" + this._id);
        iframeContainer.classList.add(Style.IframeContainer);
        iframeContainer.tabIndex = 0;
        return iframeContainer;
    };
    ModalCheckout.prototype._createBackdrop = function () {
        var backdrop = document.createElement("div");
        backdrop.setAttribute("id", "bc-backdrop-" + this._id);
        backdrop.classList.add(Style.Backdrop);
        return backdrop;
    };
    ModalCheckout.prototype._createFocusTrap = function () {
        var _this = this;
        var focusTrap = document.createElement("div");
        focusTrap.tabIndex = 0;
        focusTrap.addEventListener("focus", function () {
            return _this._container.focus();
        });
        return focusTrap;
    };
    /** The duration of animating the overlay in or out. */
    // tslint:disable-next-line:naming-convention
    ModalCheckout.ANIMATION_DURATION = 500;
    /** The defualt transition CSS value for the overlay animation. */
    ModalCheckout.DEFAULT_TRANSITION = "all " + ModalCheckout.ANIMATION_DURATION + "ms cubic-bezier(0.25, 0.8, 0.25, 1)";
    return ModalCheckout;
}(AbstractIframeCheckout));
/** All the CSS classes the modal uses. */
var Style;
(function (Style) {
    Style["Backdrop"] = "bc-backdrop";
    Style["IframeContainer"] = "bc-iframe-container";
    Style["OverlayContainer"] = "bc-overlay-container";
    Style["Leave"] = "bc-leave";
    Style["LeaveActive"] = "bc-leave-active";
    Style["Enter"] = "bc-enter";
    Style["EnterActive"] = "bc-enter-active";
})(Style || (Style = {}));
function createAndApplyStyleSheet(cspNonce) {
    // We avoid creating multiple stylesheets:
    if (document.querySelector("style[bc-style]"))
        return;
    var style = document.createElement("style");
    if (cspNonce)
        style.setAttribute("nonce", cspNonce);
    style.setAttribute("bc-style", "");
    style.appendChild(document.createTextNode(""));
    // We insert the stylesheet at the top to make style overrides easy:
    document.head.insertBefore(style, document.head.firstChild);
    var styleSheet = style.sheet;
    var addRuleToStyleSheet = addRule(styleSheet);
    addRuleToStyleSheet("." + Style.IframeContainer + ", ." + Style.OverlayContainer + ", ." + Style.Backdrop, ["width: 100vw", "height: 100vh"]);
    addRuleToStyleSheet("." + Style.OverlayContainer, [
        "z-index: 999999",
        "position: fixed"
    ]);
    addRuleToStyleSheet("." + Style.OverlayContainer + ", ." + Style.Backdrop, [
        "top: 0",
        "left: 0"
    ]);
    addRuleToStyleSheet("." + Style.Backdrop, [
        "background: rgba(0, 0, 0, 0.5)",
        "position: absolute"
    ]);
    addRuleToStyleSheet("." + Style.IframeContainer, ["position: relative"]);
    var overlayEnter = "." + Style.OverlayContainer + "." + Style.Enter;
    var overlayLeave = "." + Style.OverlayContainer + "." + Style.Leave;
    var overlayEnterActive = overlayEnter + "." + Style.EnterActive;
    var overlayLeaveActive = overlayLeave + "." + Style.LeaveActive;
    addRuleToStyleSheet(overlayEnter + ", " + overlayLeave + ", " +
        (overlayEnter + " ." + Style.Backdrop + ", ") +
        (overlayLeave + " ." + Style.Backdrop + ", ") +
        (overlayEnter + " ." + Style.IframeContainer + ", ") +
        (overlayLeave + " ." + Style.IframeContainer + ", ") +
        (overlayEnter + " iframe, ") +
        (overlayLeave + " iframe"), [
        "transition: " + ModalCheckout.DEFAULT_TRANSITION,
        "-webkit-transition: " + ModalCheckout.DEFAULT_TRANSITION
    ]);
    addRuleToStyleSheet(overlayEnter + " iframe, " + (overlayLeaveActive + " iframe"), ["opacity: 0", "transform: scale(0.1)"]);
    addRuleToStyleSheet(overlayEnter + " ." + Style.Backdrop + ", " +
        (overlayLeaveActive + " ." + Style.Backdrop), ["opacity: 0"]);
    addRuleToStyleSheet(overlayEnterActive + " ." + Style.Backdrop + ", " + overlayEnterActive + " iframe, " +
        (overlayLeave + " ." + Style.Backdrop + ", " + overlayLeave + " iframe"), ["opacity: 1"]);
    addRuleToStyleSheet(overlayEnterActive + " iframe, " + overlayLeave + " iframe", [
        "transform: scale(1)",
        "-webkit-transform: scale(1)"
    ]);
}
function addRule(styleSheet) {
    return function (selector, properties) {
        return createRule(styleSheet, selector, properties);
    };
}
function createRule(styleSheet, selector, properties) {
    styleSheet.insertRule(selector + " { " + properties.join("; ") + " }", 0);
}
function disableBodyScroll() {
    var documentElement = document.documentElement;
    var body = document.body;
    var previousDocumentStyle = documentElement.style.cssText || "";
    var previousBodyStyle = body.style.cssText || "";
    var scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;
    var clientWidth = body.clientWidth;
    var hasScrollbar = window.innerWidth > document.documentElement.clientWidth ||
        document.documentElement.scrollHeight >
            document.documentElement.clientHeight;
    if (hasScrollbar) {
        body.style.position = "fixed";
        body.style.width = "100%";
        body.style.top = -scrollTop + "px";
    }
    if (body.clientWidth < clientWidth)
        body.style.overflow = "hidden";
    if (hasScrollbar)
        documentElement.style.overflowY = "scroll";
    return function () {
        body.style.cssText = previousBodyStyle;
        documentElement.style.cssText = previousDocumentStyle;
        body.scrollTop = scrollTop;
        documentElement.scrollTop = scrollTop;
    };
}
/** Delays execution asynchronously. Does not block execution. */
function delay(duration) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, duration); })];
        });
    });
}

export { UI, InlineCheckout, RedirectCheckout, ModalCheckout, errors as Errors, CheckoutEvent$1 as Event };
