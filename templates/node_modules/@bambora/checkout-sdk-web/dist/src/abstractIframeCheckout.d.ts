import { IframeCheckoutInstanceOptions } from "./options";
import AsyncIframe from "./asyncIframe";
import AbstractCheckout from "./abstractCheckout";
import { OnOff, Emit } from "./events";
export default abstract class AbstractIframeCheckout<OptionsType extends IframeCheckoutInstanceOptions> extends AbstractCheckout<OptionsType> {
    /** Subscribe to events. */
    on: OnOff;
    /** Unsubcribe from events. */
    off: OnOff;
    /** Emit events. */
    protected _emit: Emit;
    /** Used to avoid an exception thrown in `iframe` getter when the container is falsy. */
    protected _container: Element | null;
    private _lastSessionToken?;
    /**
     * The `__asyncIframe` property should only be accessed via the `_asyncIframe` getter.
     * If you use `__asyncIframe` directly you better know what you're doing!
     */
    private __asyncIframe?;
    constructor(sessionToken: string | null, options?: Partial<OptionsType>);
    /** Removes iframe from the DOM and unhooks all events. */
    destroy(): void;
    /**
     * Tells the iframed Checkout to load a session via the `sessionToken` parameter.
     * Resolves upon successful load of session.
     * Throws `NoSessionTokenProvidedError` if no session token has been provided.
     * Throws `LoadSessionError` on failure to load session.
     */
    initialize(sessionToken?: string): Promise<string>;
    /**
     * Resolves to the `HTMLIFrameElement` iframe.
     * Throws `ContainerNotSpecifiedError` when trying to access the element
     * without having mounted it to any container.
     */
    readonly iframe: Promise<HTMLIFrameElement>;
    protected _createAsyncIframe(): void;
    protected _loadSession(token: string): Promise<string>;
    protected readonly _asyncIframe: AsyncIframe;
}
